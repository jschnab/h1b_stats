# Table of Contents
1. [Problem](README.md#problem)
2. [Approach](README.md#approach)
3. [Run instructions](README.md#run instructions)
4. [Questions?](README.md#questions?)

# Problem

The purpose of the script `h1b_stats.py` is to process H1B visa application data contained in a semicolon-separated file and provide the top occupations and states for certified applications.

There are several problems to overcome to achieve the purpose mentioned above. First, the data need to be read and loaded in a standard Python data structure. Then, we have to filter the data to find the values associated with occupation and state, and count corresponding certified applications. During these steps, one important problem is the inconsistency of column names between files corresponding to different years. After this, the count data need to be sorted in a decreasing fashion for the number of application, but in increasing alphabetical order in case there are ties between occupations. Finally, the data need to be written to a text file. All of this needs to be achieved without the help of non-standard modules such as `pandas`.

# Approach

Let's explain a possible way to solve each problem.

## Read the data

To read the data, I implemented the function `read_csv` which takes the input file name as argument. Since the user is expected to put the data in the `./input/` folder, I use the `join` function of the `os.path` module so the user can simply type the file name. I used the `csv` module from the standard library. 

First, I declare an empty list, which I will fill with lines I read from the `csv` file. I open the file using `with ... as ...:` to automatically manage file opening and closing, and use the *utf-8* encoding to prevent errors during file reading. Finally, a reader object is declared with the appropriate delimiter (semicolon) and row are iteratively read and added to the previously declared list. The function returns the list containing the data in nested lists. Each nested list contains one row of the original `csv` file.

## Get top occupations or states for certified applications

To filter the data, count the occupations or states, and save the results as a text file, I implemented two similar function called `get_top_occupations` and `get_top_states`. These functions take the following arguments: *data* is the list generated by the `read_csv` function, *top* is the number of top occupations or states which should be returned, and *output_name* is the name of the file where the user expects to find the results. 

First, I extract the column names which are stored in the first nested list of the *data* list. I iteratively go through each element of the first nested list and add them to a list called *col_names*. To get the column indexes where I can find the application status and the occupation name, I scan through *col_names* to find the ones containing the strings 'STATUS' or 'SOC_NAME'. I can now collect the occupation names and put them in a list. I iteratively go through data rows in the *data* list and appen the occupation name of this row if the status corresponds to 'CERTIFIED'.

To count the number of each occupation, I use the `Counter` tool from the `collections` module. There is a useful function called `most_common` which enables getting the *n* most common occurences. To sort the data according to our problem definition I use a lambda function. I first sort the top occurences by number, then by name in reverse order. This is done because we want to sort the top occupations in states by decreasing number but have ties sorted by alphabetical order of their names.

Then, the total number of certified applications is calculated using the `sum` function on the method `values` of the `Counter`. We will calculate the percentage of certified application for the top occupations or state when the data are saved in the text file.

Finally, the data are saved in a text file using the `writer` object from the `csv` module. Using `open ... as ...:` to automatically open and close the file, we first write column names then iteratively go through the list of top occupations or states and write them as rows of the text file. Similar to path management for the `read_csv` function, we use `os.path.join` to save the text file in the `output` directory.

Both `get_top_` functions return a list of tuples of the top occupations or states, although there are not used. This is why we set dummy variables as underscore when the code executes as a script.

## Running h1b_stats.py as a script

When the code is executed as a script, I collect the name of the input and the two output files with `sys.argv` and call the functions defined in the script.

# Run instructions

To run the script, navigate to the top of the `h1b_stats` directory and run `run.sh` in your shell. It is also possible to directly run the script `h1b_stats.py` in the `src/` folder by placing the input `csv` file in the `input` folder then entering the following instructions in the shell: `python3 ./h1b_stats <input-file-name> <output-file-name-1> <output-file-name-2>`. The output files will be saved in the output folder.

# Questions?

If you cannot find an answer to you question in this README email me at jonathan.schnabel31@gmail.com
